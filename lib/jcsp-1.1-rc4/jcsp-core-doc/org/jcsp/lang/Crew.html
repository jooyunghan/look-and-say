<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_16) on Sun Jan 25 20:01:22 GMT 2009 -->
<TITLE>
Crew (CSP for Java (JCSP) 1.1-rc4 API Specification)
</TITLE>

<META NAME="keywords" CONTENT="org.jcsp.lang.Crew class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Crew (CSP for Java (JCSP) 1.1-rc4 API Specification)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>CSP for Java<br>(JCSP) 1.1-rc4</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jcsp/lang/ConnectionServer.html" title="interface in org.jcsp.lang"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jcsp/lang/CSProcess.html" title="interface in org.jcsp.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jcsp/lang/Crew.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Crew.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.jcsp.lang</FONT>
<BR>
Class Crew</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.jcsp.lang.Crew</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Crew</B><DT>extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></DL>
</PRE>

<P>
This provides a <I>Concurrent Read Exclusive Write</I> (CREW) lock for synchronising
 fair and secure access to a shared resource.
 <P>
 <A HREF="#constructor_summary">Shortcut to the Constructor and Method Summaries.</A>

 <H2>Description</H2>
 <H3>Concurrent Read Exclusive Write</H3>
 Parallel processes must ensure controlled access to shared resources whose state can
 change as a side-effect of that access.  Otherwise, there will be <I>race hazards</I>
 resulting from arbitrary interleaving of that access between competing processes.
 For example, a <I>reader</I> of a resource may observe partially updated (and, hence,
 invalid) state because of the activities of a concurrent <I>writer</I>.
 Or two <I>writers</I> may interfere with each other's updating to leave a resource
 in an invalid state (as well as confusing themselves).
 <A NAME="Static">
 <P>
 Where possible, each resource should be kept wrapped up in a process and accessed via
 a channel interface - this will always be safe.  However, this also <I>serialises</I>
 access to the resource so that it can be used by only one process at a time,
 regardless of whether that usage is read-only or read-write.  This is an example of
 <I>Exclusive Read Exclusive Write</I> (EREW).
 <P>
 [<I>Note:</I> the above assumes the resource process has only a serial implementation.
 A parallel implementation, of course, will allow parallel access along parallel channels.
 However, if that parallel implementation needs to share state, that shared state is
 itself a resource and we have only deferred the problem of secure parallel access.]
 <P>
 Parallel <I>reader</I> operations on a resource do not lead to race hazards, so long as
 no <I>writer</I> is present, and many applications need to be able to exploit this.
 Parallel <I>writer</I> operations are always dangerous and must be suppressed.
 This principle is known as <I>Concurrent Read Exclusive Write</I> (CREW).

 <H3><A NAME="Pattern">Design Pattern</H3>
 Suppose many processes hold a reference to a shared object.  Associate that shared object
 with a shared <TT>Crew</TT> lock, reference to which must also be given to each of those
 processes.
 <P>
 For example, suppose <TT>Resource</TT> is a class whose methods may be
 classified as either <I>readers</I> (i.e. cause no state change) or <I>writers</I>
 (i.e. cause state change).  Whenever we construct a <TT>Resource</TT>, construct
 an associated <TT>Crew</TT> lock:
 <PRE>
   Resource resource = new Resource (...);
   Crew resourceCrew = new Crew ();
 </PRE>
 <A NAME="Access">
 Each process holding a reference to <TT>resource</TT> must also be given a reference
 to <TT>resourceCrew</TT>.  Invocations of <I>reader</I> methods must be sandwiched
 between a claim and release of the <I>reader</I> lock within <TT>resourceCrew</TT>:
 <PRE>
   resourceCrew.startRead(); // this will block until no writer is present
   ...                       // invoke reader methods of resource
   resourceCrew.endRead();   // releases this reader's lock on resource
 </PRE>
 Invocations of <I>writer</I> methods must be sandwiched
 between a claim and release of the <I>writer</I> lock within <TT>resourceCrew</TT>:
 <PRE>
   resourceCrew.startWrite(); // this will block until no reader
                              // or writer is present
   ...                        // invoke writer (or reader) methods
                              // of resource
   resourceCrew.endWrite();   // releases this writer's lock on resource
 </PRE>
 This pattern enables fair and secure access to a shared resource according to CREW rules.
 Concurrent readers will be allowed, so long as no writer is present.  A single writer
 will be allowed, so long as no readers nor other writers are present.  So long as each
 read or write operation is finite, readers will not be blocked indefinitely by writers
 and vice-versa (<A HREF="#Caution">but see the <I>Cautionary Note</I></A>).

 <H3><A NAME="Paranoia">Access Sequences for the Worried</H3>
 Java is a language that allows the throwing and catching of <I>exceptions</I> (and a <TT>return</TT>
 from a method invocation anywhere).
 This means that the normal sequential flow of control is not necessarilly what happens:
 <I>what-you-see-is-NOT-what-you-get</I>, a worrying property.
 If an uncaught exception is thrown (or a <TT>return</TT> executed) from
 the resource-using part of either of the above <A HREF="#Access">access sequences</A>,
 the corresponding <TT>Crew</TT> lock would not be released.
 To protect ourselves from this, embed the access sequence within
 a <TT>try</TT>-<TT>finally</TT> clause - for example:
 <PRE>
   try {
     resourceCrew.startRead(); // this will block until no writer is present
     ...                       // invoke reader methods of resource
   } finally {
     resourceCrew.endRead();   // releases this reader's lock on resource
   }
 </PRE>
 and:
 <PRE>
   try {
     resourceCrew.startWrite(); // this will block until no reader
                                // or writer is present
     ...                        // invoke writer (or reader)
                                // methods of resource
   } finally {
     resourceCrew.endWrite ();  // releases this writer's lock on resource
   }
 </PRE>
 Now, the lock will always be released whether the reader/writer section exits normally
 or exceptionally.  This asymmetric pattern is not very pretty, but is a classic
 application of the <TT>try</TT>-<TT>finally</TT> facility.

 <H3><A NAME="Binding">Binding the Shared Resource to its CREW Lock</H3>
 In JCSP, shared references may be passed to processes through constructors, through
 mutator (<TT>set...</TT>) methods (but only, of course, before and in between runs)
 or through channels (when running).
 <P>
 If a resource and its lock are held in separate objects (as above), passing them
 <I>both</I> to the processes that share them is a little tedious and error prone.
 It is better to combine them into a <I>single</I> object.
 <P>
 One way is to define the <TT>Resource</TT> class to <TT>extend</TT> <TT>Crew</TT>.
 Then, we only need to distribute the <TT>Resource</TT> object and its access is
 protected by inherited methods - for example:
 <PRE>
   resource.startRead ();        // this will block until no writer is present
   ...                           // invoke reader methods of resource
   resource.endRead ();          // releases this reader's lock on resource
 </PRE>
 However, this may not be possible (since our design may require <TT>Resource</TT>
 to <TT>extend</TT> something else).
 <P>
 Alternatively, we could declare (or <TT>extend</TT>) <TT>Resource</TT> to contain
 an additional <TT>Crew</TT> attribute.  Again, we need only distribute
 the <TT>Resource</TT> object.  The sharing processes recover the associated lock:
 <PRE>
   Crew resourceCrew = resource.getCrew ();
 </PRE>
 and can use the <A HREF="#Access">original access sequences</A>.
 <P>
 However, this <TT>Crew</TT> class offers the option of doing this the other way around,
 so that no modifications are needed on the application <TT>Resource</TT>.  Pass the
 <TT>Resource</TT> object to the <TT>Crew</TT> <A HREF="../../../org/jcsp/lang/Crew.html#Crew(java.lang.Object)"><CODE>constructor</CODE></A>
 and a reference will be saved as an attribute of the <TT>Crew</TT> object.  For example:
 <PRE>
   Crew resourceCrew = new Crew (new Resource (...));
 </PRE>
 Processes to which this <TT>resourceCrew</TT> object are distributed can recover
 the original resource by invoking <A HREF="../../../org/jcsp/lang/Crew.html#getShared()"><CODE><TT>getShared</TT></CODE></A> - for example:
 <PRE>
   Resource resource = (Resource) resourceCrew.getShared ();
 </PRE>
 and can again use the <A HREF="#Access">original access sequences</A>.

 <H3><A NAME="Binding">CREW-synchronised Methods</H3>
 The safest way to ensure adherence to the <A HREF="#Pattern">design pattern</A>
 is to burn the correct access sequence into each <I>reader</I> and <I>writer</I> method.
 For example, extend <TT>Resource</TT> to contain a <TT>private</TT>
 <TT>Crew</TT> field and override each method to sandwich its invocation
 between the appropriate synchronisations:
 <PRE>
 class ResourceCrew extends Resource {
 <I></I>
   private final Crew crew = new Crew ();
 <I></I>
   public Thing readerMethod (...) {
     crew.startRead ();      // this will block until no writer is present
     Thing result = super.readerMethod (...);
     crew.endRead ();        // releases this reader's lock on resource
     return result;
   }
 <I></I>
   public void writerMethod (...) {
     crew.startWrite ();     // this will block until no reader
                             // or writer is present
     super.writerMethod (...);
     crew.endWrite ();       // releases this writer's lock on resource
   }
 <I></I>
   ...  etc. for all other methods.
 <I></I>
 }
 </PRE>
 Now, parallel processes can safely share references to an instance of
 <TT>ResourceCrew</TT>.  Invocations of its <I>reader</I> and <I>writer</I>
 methods will be automatically CREW-synchronised.
 <P>
 Notes:
 <UL>
   <LI>
     this is similar to declaring all class methods to be <TT>synchronized</TT>
     (which guarantees EREW-synchronisation for parallel access to its instances);
   <LI>
     it <I>may</I> have been better to have designed <TT>Resource</TT> like this
     in the first place (rather than extending it as in the above);
   <LI>
     the above access sequences may need to be of the <A HREF="#Paranoia">defensive</A>
     variety;
   <LI>
     a disadvantage of this approach is that we do not have the capability of grouping
     a sequence of <I>reader</I> or <I>reader</I>/<I>writer</I> methods within a single
     CREW-synchronisation envelope.
 </UL>

 <H2><A NAME="Alternatives">Alternatives to CREW for Shared Objects</H2>
 The proliferation of references in object-oriented design is a common source of error,
 even for single-threaded systems.  For concurrent object-oriented design, we must be
 especially careful if we are to avoid the perils of race hazard.
 <P>
 Protocols other than CREW may be applied to ensure
 the safe parallel use of these references.  For instance, if the shared reference is to
 an <I>immutable</I> object (like <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/String.html" title="class or interface in java.lang"><CODE><TT>String</TT></CODE></A>), no special
 action is needed - this is <I>Concurrent Read</I> (CR).
 <P>
 On the other hand, if a reference to a <I>mutable</I> object (<TT>A</TT>) is passed
 between processes over channels, the sender may agree not to refer to <TT>A</TT>
 (nor to any objects referred to within <TT>A</TT>) in the future - unless, of course,
 the original reference to <TT>A</TT> is passed back.  In this way, the reference acts
 as a <I>unique token</I>, possesion of which must be held before access is allowed.
 See also <A HREF="../../../org/jcsp/plugNplay/Paraplex.html" title="class in org.jcsp.plugNplay"><CODE>Paraplex</CODE></A> for a <I>double buffering</I> adaptation of this.
 <P>
 Such patterns give us safe, secure and dynamic forms of <I>Exclusive Read Exclusive
 Write</I> (EREW) sharing which, along with the dynamic CREW provided by this class,
 complement the <A HREF="#Static">static control automatically conferred by the CSP
 process model</A>. We just have to know when each is appropriate and apply them
 with due care.

 <H2>Implementation Note</H2>
 Channels, which are a specialisation of the multiway CSP <I>event</I>, are a fundamental
 primitive for synchronising the actions of concurrent processes.  Common patterns of
 use have given rise to higher-level synchronisation paradigms that (when applicable)
 are easier and, therefore, safer to use than the raw primitives.  This CREW
 lock is an example of this.  [Another is the
 <A HREF="../../../org/jcsp/lang/One2OneCallChannel.html" title="class in org.jcsp.lang"><CODE><I>CALL</I> channel</CODE></A>.]
 <P>
 The implementation is given here because it is short and simple - an example of the power
 of expression (and provability) that follows from the CSP/occam model.  Correct
 implementation of a CREW lock has been notoriously difficult.  See, for example,
 Hoare's short but rather tricky solution from his paper, <I>`Monitors: an Operating
 System Structuring Concept'</I> [C.A.R.Hoare, CACM, 17(10) pp. 549-557, October 1974] -
 a paper often quoted as one of the sources for the Java monitor model.  In contrast,
 this CSP version is easy <I>and that easiness is important</I>.
 <P>
 Each <TT>Crew</TT> object spawns off a private and anonymous <TT>CrewServer</TT> process
 with which it interacts only via channels:
 <p><IMG SRC="doc-files/Crew1.gif"></p>
 All accessing processes
 (i.e. the <A HREF="../../../org/jcsp/lang/Crew.html#startRead()"><CODE><TT>startRead</TT></CODE></A>/<A HREF="../../../org/jcsp/lang/Crew.html#startWrite()"><CODE><TT>startWrite</TT></CODE></A>
 methods) communicate down the <I>any-1</I> <TT>request</TT> channel, identifying
 themselves as either a <TT>READER</TT> or <TT>WRITER</TT>:
 <PRE>
   public void startRead () {
     request.write (CrewServer.READER);
   }
 <I></I>
   public void startWrite () {
     request.write (CrewServer.WRITER);
     writerControl.write (0);
     // wait for all current readers to finish
   }
 </PRE>
 For <TT>startRead</TT>, this is all that happens - <TT>CrewServer</TT> will refuse
 the communication if there is a writer present.  When accepted, there will be no writer
 present and the reader has permission to read the shared resource.
 <P>
 The <TT>startWrite</TT> communication will also be refused if another writer is present.
 If there are readers present, it is accepted.  This has to be the case since, as far as
 the <TT>CrewServer</TT> is aware, it might have been from a <TT>startRead</TT>.
 So, acceptance of this communication does not yet give the writer permission to start
 writing - but it does let <TT>CrewServer</TT> know that a writer wants to write.
 To get that permission, the writer performs a second communication on
  <TT>writerControl</TT> - see above.
 <P>
 After accepting a writer <TT>request</TT>, <TT>CrewServer</TT> refuses further
 communications on <TT>request</TT> and <TT>writerControl</TT> until all readers have
 finished - which they do by signalling on <TT>readerRelease</TT>:
 <PRE>
   public void endRead () {
     readerRelease.write (0);
   }
 </PRE>
 Refusing the <TT>request</TT> channel parks newly arriving readers and writers safely.
 When all existing readers have gone away, <TT>CrewServer</TT> accepts the outstanding
 communication on <TT>writerControl</TT>, which gives the waiting writer permission
 to write.  <TT>CrewServer</TT> then waits for a second communication on
 <TT>writerControl</TT>, which is the signal from the writer that it has finished writing:
 <PRE>
   public void endWrite () {
     writerControl.write (0);
   }
 </PRE>
 before returning to its initial state (listening on <TT>request</TT> and
 <TT>readerRelease</TT>).
 <P>
 The logic is easier to explain in JCSP:
 <PRE>
 package org.jcsp.lang;
 <I></I>
 class CrewServer implements CSProcess {      // this is not a public class
 <I></I>
   public static final int READER = 0;
   public static final int WRITER = 1;
 <I></I>
   private final AltingChannelInputInt request;
   private final ChannelInputInt writerControl;
   private final AltingChannelInputInt readerRelease;
 <I></I>
   public CrewServer (final AltingChannelInputInt request,
                      final ChannelInputInt writerControl,
                      final AltingChannelInputInt readerRelease) {
     this.request = request;
     this.writerControl = writerControl;
     this.readerRelease = readerRelease;
   }
 <I></I>
   public void run () {
     int nReaders = 0;
     Guard[] c = {readerRelease, request};
     final int READER_RELEASE = 0;
     final int REQUEST = 1;
     Alternative alt = new Alternative (c);
     while (true) {
       // invariant : (nReaders is the number of current readers) and
       // invariant : (there are no writers)
       switch (alt.priSelect ()) {
         case READER_RELEASE:
           readerRelease.read ();         // always let a reader finish reading
           nReaders--;
         break;
         case REQUEST:
           switch (request.read ()) {
             case READER:
               nReaders++;                // let a reader start reading
             break;
             case WRITER:
               for (int i = 0; i < nReaders; i++) {
                 readerRelease.read ();   // wait for all readers to go away
               }
               nReaders = 0;
               writerControl.read ();     // let the writer start writing
               writerControl.read ();     // wait for writer to finish writing
             break;
           }
         break;
       }
     }
   }
 <I></I>
 }
 </PRE>
 Note that a <TT>CrewServer</TT> cannot be misused by reader and writer processes.
 It is <TT>private</TT> to each <TT>Crew</TT> lock and operated correctly by the
 methods of that lock.  Given this correct operation, it is trivial to establish
 the declared <I>loop invariant</I>.  All readers and writers start by communicating
 on the <TT>request</TT> channel so, so long as that is
 <A HREF="#Caution"><I>fairly</I> serviced</A> and that no read or write lasts forever,
 processes cannot be indefinitely blocked (e.g. readers by writers or writers by readers).

 <H3><A NAME="Caution">Cautionary Note</H3>
 <I>Fair</I> servicing of readers and writers in the above depends on <I>fair</I>
 servicing of the <A HREF="../../../org/jcsp/lang/Any2OneChannelInt.html" title="interface in org.jcsp.lang"><CODE><I>any-1</I></CODE></A> <TT>request</TT> and
 <TT>readerRelease</TT> channels.  In turn, this depends on the <I>fair</I>
 servicing of requests to enter a <TT>synchronized</TT> block (or method) by
 the underlying Java Virtual Machine (JVM).  Java does not specify how threads
 waiting to synchronize should be handled.  Currently, Sun's standard JDKs queue
 these requests - which is <I>fair</I>.  However, there is at least one JVM
 that puts such competing requests on a stack - which is legal but <I>unfair</I>
 and can lead to infinite starvation.  This is a problem for <I>any</I> Java system
 relying on good behaviour from <TT>synchronized</TT>, not just for JCSP's
 <I>any-1</I> channels or <TT>Crew</TT> locks.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>P.H. Welch</DD>
</DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Crew.html#Crew()">Crew</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct a lock for CREW-guarded operations on a shared resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Crew.html#Crew(java.lang.Object)">Crew</A></B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A>&nbsp;shared)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct a lock for CREW-guarded operations on a shared resource.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Crew.html#endRead()">endRead</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This must be invoked <I>after</I> any read operations on the associated shared resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Crew.html#endWrite()">endWrite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This must be invoked <I>after</I> any write operations on the associated shared resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Crew.html#finalize()">finalize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finalize method added to terminate the process that it spawned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Crew.html#getShared()">getShared</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This returns the shared resource associated with this lock by its
 <A HREF="../../../org/jcsp/lang/Crew.html#Crew(java.lang.Object)"><CODE>constructor</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Crew.html#startRead()">startRead</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This must be invoked <I>before</I> any read operations on the associated shared resource.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Crew.html#startWrite()">startWrite</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This must be invoked <I>before</I> any write operations on the associated shared resource.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Crew()"><!-- --></A><H3>
Crew</H3>
<PRE>
public <B>Crew</B>()</PRE>
<DL>
<DD>Construct a lock for CREW-guarded operations on a shared resource.
<P>
</DL>
<HR>

<A NAME="Crew(java.lang.Object)"><!-- --></A><H3>
Crew</H3>
<PRE>
public <B>Crew</B>(<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A>&nbsp;shared)</PRE>
<DL>
<DD>Construct a lock for CREW-guarded operations on a shared resource.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>shared</CODE> - the shared resource for which this lock is to be used (see
 <A HREF="../../../org/jcsp/lang/Crew.html#getShared()"><CODE><TT>getShared</TT></CODE></A>).</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="finalize()"><!-- --></A><H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()
                 throws <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Throwable.html" title="class or interface in java.lang">Throwable</A></PRE>
<DL>
<DD>Finalize method added to terminate the process that it spawned. The spawned process holds no references
 to this object so this object will eventually fall out of scope and gets finalized.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A></CODE> in class <CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Throwable.html" title="class or interface in java.lang">Throwable</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="startRead()"><!-- --></A><H3>
startRead</H3>
<PRE>
public void <B>startRead</B>()</PRE>
<DL>
<DD>This must be invoked <I>before</I> any read operations on the associated shared resource.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="endRead()"><!-- --></A><H3>
endRead</H3>
<PRE>
public void <B>endRead</B>()</PRE>
<DL>
<DD>This must be invoked <I>after</I> any read operations on the associated shared resource.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="startWrite()"><!-- --></A><H3>
startWrite</H3>
<PRE>
public void <B>startWrite</B>()</PRE>
<DL>
<DD>This must be invoked <I>before</I> any write operations on the associated shared resource.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="endWrite()"><!-- --></A><H3>
endWrite</H3>
<PRE>
public void <B>endWrite</B>()</PRE>
<DL>
<DD>This must be invoked <I>after</I> any write operations on the associated shared resource.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getShared()"><!-- --></A><H3>
getShared</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A> <B>getShared</B>()</PRE>
<DL>
<DD>This returns the shared resource associated with this lock by its
 <A HREF="../../../org/jcsp/lang/Crew.html#Crew(java.lang.Object)"><CODE>constructor</CODE></A>.
 Note: if the <A HREF="../../../org/jcsp/lang/Crew.html#Crew(java.lang.Object)"><CODE>parameterless constructor</CODE></A> was used,
 this will return <TT>null</TT>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the shared resource associated with this lock.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>CSP for Java<br>(JCSP) 1.1-rc4</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jcsp/lang/ConnectionServer.html" title="interface in org.jcsp.lang"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jcsp/lang/CSProcess.html" title="interface in org.jcsp.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jcsp/lang/Crew.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Crew.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=\'-1\'><A HREF=\'mailto:jcsp-team@kent.ac.uk\'>Submit a bug or feature to jcsp-team@kent.ac.uk</A><br>Version 1.1-rc4 of the JCSP API Specification (Copyright 1997-2008 P.D.Austin and P.H.Welch - All Rights Reserved)<br>Java is a trademark or registered trademark of Sun Microsystems, Inc. in the US and other countries.
</BODY>
</HTML>
