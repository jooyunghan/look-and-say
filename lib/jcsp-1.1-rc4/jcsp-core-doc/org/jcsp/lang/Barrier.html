<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_16) on Sun Jan 25 20:01:21 GMT 2009 -->
<TITLE>
Barrier (CSP for Java (JCSP) 1.1-rc4 API Specification)
</TITLE>

<META NAME="keywords" CONTENT="org.jcsp.lang.Barrier class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Barrier (CSP for Java (JCSP) 1.1-rc4 API Specification)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>CSP for Java<br>(JCSP) 1.1-rc4</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jcsp/lang/Any2OneConnection.html" title="interface in org.jcsp.lang"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jcsp/lang/BarrierError.html" title="class in org.jcsp.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jcsp/lang/Barrier.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Barrier.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.jcsp.lang</FONT>
<BR>
Class Barrier</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.jcsp.lang.Barrier</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html" title="class or interface in java.io">Serializable</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Barrier</B><DT>extends <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A><DT>implements <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html" title="class or interface in java.io">Serializable</A></DL>
</PRE>

<P>
This enables <I>barrier</I> synchronisation between a set of processes.
 <P>
 <A HREF="#constructor_summary">Shortcut to the Constructor and Method Summaries.</A>
 
 <H2>Description</H2>
 A channel is a CSP <I>event</I> in which only two processes (the reader and
 the writer) synchronise.  A barrier is a CSP <I>event</I> in which any number of
 processes may synchronise.  <I>Any</I> process synchronising on a barrier will be
 blocked until <I>all</I> processes associated with that barrier have synchronised.
 A process may not back off an attempted synchronisation - i.e. barriers cannot be
 used as guards in an <A HREF="../../../org/jcsp/lang/Alternative.html" title="class in org.jcsp.lang"><CODE>Alternative</CODE></A>.
 Applications needing that capability should use an <A HREF="../../../org/jcsp/lang/AltingBarrier.html" title="class in org.jcsp.lang"><CODE>AltingBarrier</CODE></A>.
 <P>
 A process network may contain many barriers - each being associated with a different
 subset of processes.  These subsets may overlap and change at run-time.  JCSP does not
 currently provide a checked way of associating a process with a particular barrier.
 That could be done, but would carry a syntactic and run-time overhead currently not
 thought worthwhile.  Associating a barrier with its correct set of processes is
 a design issue and it is left to the designer to ensure correct useage.
 <P>
 <I>Note:</I> this notion of barrier corresponds to the
 <A HREF="http://frmb.org/occ21-extensions-clean.html#barrier"><tt>BARRIER</tt></A>
 synchronisation primitive added to the
 <A HREF="http://www.cs.kent.ac.uk/projects/ofa/kroc/">KRoC</A>
 <A HREF="http://occam-pi.org/"><B>occam-pi</B></A> language system.
 
 <H3>Deterministic Barriers</H3>
 If the set of processes associated with a barrier remains fixed, barrier synchronisation
 introduces no <I>non-determinism</I>.  So, a parallel system made up of processes,
 barriers (with fixed barrier sets) and 1-1 channels (with no ALTing on the channels and
 an exclusive read/write access discipline for all communicated objects) is deterministic
 - its semantics are independent of scheduling.
 <P>
 For fixed barrier sets, <A HREF="../../../org/jcsp/lang/Barrier.html#Barrier(int)"><CODE><R>construct</R></CODE></A> each barrier initialised
 to the number of processes to be associated with it and share it out amongst those processes.
 <P>
 For example, here is a fixed set of 10 processes synchronising on a shared barrier:
 <p><IMG SRC="doc-files/Barrier1.gif"></p>
 Here is the JCSP code for this network:
 <PRE>
 import org.jcsp.lang.*;
 
 public class BarrierExample1 {
 
   public static void main (String[] args) {
 
     final int nPlayers = 10;
 
     final Barrier barrier = new Barrier (nPlayers);
 
     final Player[] players = new Player[nPlayers];
     for (int i = 0; i < players.length; i++) {
       players[i] = new Player (i, nPlayers, barrier);
     }
 
     new Parallel (players).run ();
 
   }
 
 }
 </PRE>
 To synchronise on a barrier, a process just needs to invoke its <A HREF="../../../org/jcsp/lang/Barrier.html#sync()"><CODE>sync</CODE></A>
 method.  For example:
 <PRE>
 import org.jcsp.lang.*;
 
 public class Player implements CSProcess {
 
   private final int id, nPlayers;
   private final Barrier barrier;
 
   public Player (int id, int nPlayers, Barrier barrier) {
     this.id = id;
     this.nPlayers = nPlayers;
     this.barrier = barrier;
   }
 
   public void run () {
     final CSTimer tim = new CSTimer ();
     final long second = 1000;          // JCSP timer units are milliseconds
     int busy = id + 1;
     while (true) {
       tim.sleep (busy*second);         // application specific work
       System.out.println ("Player " + id + " at the barrier ...");
       barrier.sync ();
       System.out.println ("\t\t\t... Player " + id + " over the barrier");
       busy = (nPlayers + 1) - busy;    // just to make it more interesting
     }
   }
 
 }
 </PRE>
 The <TT>sleep</TT> period above represents some work carried out by each <TT>Player</TT>.
 This work takes a different amount of time in each cycle and varies from player to player.
 At the end of each piece of work, each player waits for all its colleagues before continuing
 its next cycle.
 
 <H3><A NAME="ND-barrier">Non-Deterministic Barriers</H3>
 A process may choose at any time to <A HREF="../../../org/jcsp/lang/Barrier.html#enroll()"><CODE>enroll</CODE></A> or <A HREF="../../../org/jcsp/lang/Barrier.html#resign()"><CODE>resign</CODE></A> from
 any barrier it can see.  It should not, of course, <TT>enroll</TT> on a barrier with which
 it is already associated - nor <TT>resign</TT> from a barrier with which it isn't!  Because
 these operations are internal choices of individual processes and because they have an impact on
 the synchronisation properties of their environment, the resulting system is non-deterministic.
 <A NAME="Worker-TimeKeeper">
 <p><IMG SRC="doc-files/Barrier2.gif"></p>
 In the above example, <TT>Worker</TT> processes cycle between <I>working</I> and
 <I>resting</I> states, making their own decisions about when to switch.
 When <I>working</I>, they enroll in a barrier shared with a <TT>TimeKeeper</TT> process -
 when <I>resting</I>, they resign from this barrier.
 Whilst <I>working</I> and after they have enrolled, they execute a sequence of
 <I>work units</I> triggered by synchronisations on the barrier.
 <P>
 The <TT>TimeKeeper</TT> synchronises on the barrier at a regular rate (once per second)
 and, thus, coordinates the activities of all <I>working</I> <TT>Worker</TT>s.
 A <I>work unit</I> can only start at the beginning of one of the <TT>TimeKeeper</TT>'s
 time slots and each <TT>Worker</TT> can only perform one <I>work unit</I> per time slot.
 Should any <I>work unit</I> overrun a time slot, subsequent units (for all <TT>Worker</TT>s)
 will have a late start.
 However, the system is stable - so long as there is some slack in the system
 (i.e. units do not <I>generally</I> overrun), the original schedule will be recovered.
 <P>
 Here is the code for the complete system.
 The <TT>barrier</TT> is initialised to just <TT>1</TT>, since only the <TT>TimeKeeper</TT>
 is permanently associated with it.
 The <TT>barrier</TT> is passed to all <TT>Worker</TT>s as well as to the <TT>TimeKeeper</TT>:
 <PRE>
 import org.jcsp.lang.*;
 
 public class BarrierExample2 {
 
   public static void main (String[] args) {
 
     final int nWorkers = 10;
     final int rogue = 5;
 
     final int second = 1000;
     // JCSP timer units are milliseconds
     final int tick = 1*second;
     final int maxWork = tick;
     // raise this to allow workers to overrun
 
     final long seed = new CSTimer ().read ();
 
     final Barrier barrier = new Barrier (1);
 
     final TimeKeeper timeKeeper = new TimeKeeper (tick, barrier);
 
     final Worker[] workers = new Worker[nWorkers];
     for (int i = 0; i < workers.length; i++) {
       workers[i] = new Worker (i, i + seed, maxWork, i == rogue, barrier);
     }
 
     new Parallel (
       new CSProcess[] {
         timeKeeper,
         new Parallel (workers)
       }
     ).run ();
   }
 }
 </PRE>
 As well as the <TT>barrier</TT>, each <TT>Worker</TT> is given its <TT>id</TT>, a (unique)
 <TT>seed</TT> for its random number generator, its maximum work unit time and whether it is
 a <TT>rogue</TT>.  A rogue worker deliberately overruns its last unit of work for each
 working session to test out the stability of the system:
 <PRE>
 import org.jcsp.lang.*;
 import java.util.*;
 
 public class Worker implements CSProcess {
 
   private final int id;
   private final long seed;
   private final int maxWork;
   private final boolean rogue;
   private final Barrier barrier;
 
   public Worker (int id, long seed, int maxWork,
                  boolean rogue, Barrier barrier) {
     this.id = id;
     this.seed = seed;
     this.maxWork = maxWork;
     this.rogue = rogue;
     this.barrier = barrier;
   }
 
   public void run () {
 
     final Random random = new Random (seed);
     // each process gets a different seed
 
     final CSTimer tim = new CSTimer ();
     final int second = 1000;
     // JCSP timer units are milliseconds
 
     final int minRest = 3*second;
     final int maxRest = (id + 10)*second;
     final int nWorkUnits = id + 1;
 
     final String starting = "\tWorker " + id
                             + " starting ...";
     final String  working = "\t\t\t  ... Worker " + id
                             + " working ...";
     final String  resting = "\t\t\t\t\t       ... Worker "
                             + id + " resting ...";
 
     while (true) {
       barrier.enroll ();
       System.out.println (starting);
       for (int i = 0; i < nWorkUnits; i++) {
         barrier.sync ();
         System.out.println (working);
         tim.sleep (random.nextInt (maxWork));
         //these lines represent one unit of work
       }
       if (rogue) tim.sleep (maxWork);
       // try to throw the timekeeper
       barrier.resign ();
       System.out.println (resting);
       tim.sleep (minRest + random.nextInt (maxRest));
     }
   }
 
 }
 </PRE>
 Note that the <A HREF="../../../org/jcsp/lang/Barrier.html#resign()"><CODE>resign</CODE></A> method also performs a (non-blocking) synchronisation
 on the barrier as well as the resignation.  This is crucial since, if the resigner were
 the last process associated with a barrier not to have invoked a <A HREF="../../../org/jcsp/lang/Barrier.html#sync()"><CODE>sync</CODE></A>,
 its resignation must <I>complete</I> the barrier (as though it had invoked a <TT>sync</TT>)
 and release all the remaining associated processes.
 <P>
 The <TT>TimeKeeper</TT> is passed its <TT>tick</TT> interval and the <TT>Barrier</TT>.
 It is pre-enrolled with the <TT>Barrier</TT> and remains permanently associated:
 <PRE>
 import org.jcsp.lang.*;
 
 public class TimeKeeper implements CSProcess {
 
   private final long interval;
   private final Barrier barrier;
 
   public TimeKeeper (long interval, Barrier barrier) {
     this.interval = interval;
     this.barrier = barrier;
   }
 
   public void run () {
 
     final CSTimer tim = new CSTimer ();
     long timeout = tim.read () + interval;
 
     while (true) {
       tim.after (timeout);
       barrier.sync ();
       System.out.println ("[" + (tim.read () - timeout) + "]");
       timeout += interval;
     }
   }
 
 }
 </PRE>
 The print statement from the <TT>TimeKeeper</TT> gives an upper bound on how far each
 timeslot strays from its schedule.  JCSP <A HREF="../../../org/jcsp/lang/CSTimer.html" title="class in org.jcsp.lang"><CODE>CSTimer</CODE></A>s are currently implemented
 on top of standard Java APIs (<TT>Thread.sleep</TT> and <TT>Object.wait</TT>).
 Depending on the underlying JVM, this should stay close to zero (milliseconds) - except
 when the rogue <TT>Worker</TT> deliberately overruns a work unit.
 Other events may also disturb the schedule - e.g. a <TT>Ctl-S</TT>/<TT>Ctl-Q</TT> from
 the user to <I>pause</I>/<I>resume</I> output or some transient fit of activity from
 the operating system.  Some JVMs also return early from some timeouts - i.e. the timeslot
 starts early, which gives rise to an occasional negative report from the <TT>TimeKeeper</TT>.
 <P>
 Bear also in mind that the <TT>TimeKeeper</TT>'s print statement has to compete with
 the print statements from all working <TT>Worker</TT>s.  All are scheduled to execute
 at the start of each timeslot and may be arbitrarilly interleaved.
 This may be confusing when interpreting the output from the system.
 <P>
 To clarify what's happening, we can arrange for the <TT>TimeKeeper</TT>'s message
 to be printed first for each timeslot, <I>before</I> any from the <TT>Worker</TT>s.
 To do this, we need to stall those <TT>Worker</TT>s temporarilly until we know that
 the <TT>TimeKeeper</TT> has reported.  A simple way to do that is to double up on
 the barrier synchronisation.  For the <TT>Worker</TT>, modify its <I>working</I> loop:
 <PRE>
   for (int i = 0; i < nWorkUnits; i++) {
     barrier.sync ();                     // wait for everyone
     barrier.sync ();                     // wait for the Timekeeper to report
     System.out.println (working);
     tim.sleep (random.nextInt (maxWork));
   }
 </PRE>
 For the <TT>TimeKeeper</TT>, modify its <TT>run</TT> loop:
 <PRE>
   while (true) {
     tim.after (timeout);
     barrier.sync ();                     // wait for everyone
     System.out.println ("[" + (tim.read () - timeout) + "]");
     barrier.sync ();                     // let the Workers get going
     timeout += interval;
   }
 </PRE>
 
 <H3>Overheads</H3>
 Free use of additional synchronisations to gain special control (such as in the above)
 depends on the overheads being not so great as to render that control pointless.
 <P>
 Going back to the <A HREF="#Worker-TimeKeeper">original example</A>, the entire barrier
 synchronisation could be discarded by dropping the <TT>TimeKeeper</TT> and making each
 <TT>Worker</TT> responsible for its own time schedule.
 However, setting <TT>n</TT> timeouts (where each setting has <TT>O(n)</TT> overheads)
 needs to be compared against setting <TT>1</TT> timeout (by the <TT>TimeKeeper</TT>)
 together with a <TT>(n+1)</TT>-way barrier synchronisation.
 <P>
 For the current implementation, the <A HREF="../../../org/jcsp/lang/Barrier.html#enroll()"><CODE>enroll</CODE></A> and <A HREF="../../../org/jcsp/lang/Barrier.html#resign()"><CODE>resign</CODE></A>
 operations - together with <I>most</I> of the <A HREF="../../../org/jcsp/lang/Barrier.html#sync()"><CODE>sync</CODE></A>s - have unit time
 costs.  The <I>final</I> <TT>sync</TT>, which releases all the other (<TT>n</TT>)
 processes blocked on the barrier, takes <TT>O(n)</TT> time.  The unit time costs
 for this implementation are comparable with those of a <TT>synchronized</TT> method
 invocation followed by an <TT>Object.wait</TT>.
 <P>
 [<I>Note:</I> CSP synchronisation primitives can be implemented with much lighter
 overheads.  For example,
 the <A HREF="http://www.hensa.ac.uk/parallel/occam/projects/occam-for-all/kroc/">KRoC</A>
 <B>occam</B> equivalent to this <TT>Barrier</TT>
 (its <A HREF="http://www.hensa.ac.uk/parallel/occam/projects/occam-for-all/hlps/">EVENT</A>)
 has (sub-microsecond) unit time costs for <I>all</I> its operations, including
 the <I>final</I> <TT>sync</TT>.  Future work on JCSP may look towards this standard.]
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>P.H. Welch</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/jcsp/lang/AltingBarrier.html" title="class in org.jcsp.lang"><CODE>AltingBarrier</CODE></A>, 
<A HREF="../../../org/jcsp/lang/Bucket.html" title="class in org.jcsp.lang"><CODE>Bucket</CODE></A>, 
<A HREF="../../../org/jcsp/lang/Alternative.html" title="class in org.jcsp.lang"><CODE>Alternative</CODE></A>, 
<A HREF="../../../serialized-form.html#org.jcsp.lang.Barrier">Serialized Form</A></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Barrier.html#Barrier()">Barrier</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct a barrier initially associated with no processes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Barrier.html#Barrier(int)">Barrier</A></B>(int&nbsp;nEnrolled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct a barrier (initially) associated with <TT>nEnrolled</TT> processes.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Barrier.html#enroll()">enroll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A process may enroll only if it is resigned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Barrier.html#reset(int)">reset</A></B>(int&nbsp;nEnrolled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reset this barrier to be associated with <TT>nEnrolled</TT> processes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Barrier.html#resign()">resign</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A process may resign only if it is enrolled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jcsp/lang/Barrier.html#sync()">sync</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Synchronise the invoking process on this barrier.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Barrier()"><!-- --></A><H3>
Barrier</H3>
<PRE>
public <B>Barrier</B>()</PRE>
<DL>
<DD>Construct a barrier initially associated with no processes.
<P>
</DL>
<HR>

<A NAME="Barrier(int)"><!-- --></A><H3>
Barrier</H3>
<PRE>
public <B>Barrier</B>(int&nbsp;nEnrolled)</PRE>
<DL>
<DD>Construct a barrier (initially) associated with <TT>nEnrolled</TT> processes.
 It is the responsibility of the constructing process to pass this
 (by constructor or <tt>set</tt> method) to each process that will be
 synchronising on the barrier, <i>before</i> firing up those processes.
 <p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>nEnrolled</CODE> - the number of processes (initially) associated with this barrier.
 <p>
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if <tt>nEnrolled</tt> < <tt>0</tt>.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="reset(int)"><!-- --></A><H3>
reset</H3>
<PRE>
public void <B>reset</B>(int&nbsp;nEnrolled)</PRE>
<DL>
<DD>Reset this barrier to be associated with <TT>nEnrolled</TT> processes.
 This must only be done at a time when no processes are active on the barrier.
 It is the responsibility of the invoking process to pass this barrier
 (by constructor or <tt>set</tt> method) to each process that will be
 synchronising on the barrier, <i>before</i> firing up those processes.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nEnrolled</CODE> - the number of processes reset to this barrier.
 <p>
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if <tt>nEnrolled</tt> < <tt>0</tt>.</DL>
</DD>
</DL>
<HR>

<A NAME="sync()"><!-- --></A><H3>
sync</H3>
<PRE>
public void <B>sync</B>()</PRE>
<DL>
<DD>Synchronise the invoking process on this barrier.
 <I>Any</I> process synchronising on this barrier will be blocked until <I>all</I>
 processes associated with the barrier have synchronised (or resigned).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="enroll()"><!-- --></A><H3>
enroll</H3>
<PRE>
public void <B>enroll</B>()</PRE>
<DL>
<DD>A process may enroll only if it is resigned.
 A re-enrolled process may resume offering to synchronise on this barrier
 (until a subsequent <A HREF="../../../org/jcsp/lang/Barrier.html#resign()"><CODE>resign</CODE></A>).
 Other processes cannot complete the barrier (represented by this front-end)
 without participation by the re-enrolled process.
 <p>
 <i>Note:</i> timing re-enrollment on a barrier usually needs some care.
 If the barrier is being used for synchronising phases of execution between
 a set of processes, it is crucial that re-enrollment occurs in
 an appropriate <i>(not arbitrary)</i> phase.
 If the trigger for re-enrollment comes from another enrolled process,
 that process should be in such an appropriate phase.
 The resigned process should re-enroll and, then, acknowledge the trigger.
 The triggering process should wait for that acknowledgement.
 If the decision to re-enroll is internal (e.g. following a timeout),
 a <i>buddy</i> process, enrolled on the barrier, should be asked to provide
 that trigger when in an appropriate phase.
 The <i>buddy</i> process, perhaps specially built just for this purpose, polls
 a service channel for that question when in that phase.
 </p>
 <p>
 <i>Warning:</i> the rule in the first sentence above is
 the responsibility of the designer -- it is not checked by
 implementation.
 If not honoured, things will go wrong.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resign()"><!-- --></A><H3>
resign</H3>
<PRE>
public void <B>resign</B>()</PRE>
<DL>
<DD>A process may resign only if it is enrolled.
 A resigned process may not offer to synchronise on this barrier
 (until a subsequent <A HREF="../../../org/jcsp/lang/Barrier.html#enroll()"><CODE>enroll</CODE></A>).
 Other processes can complete the barrier (represented by this front-end)
 without participation by the resigned process.
 <p>
 Unless <i>all</i> processes synchronising on this barrier terminate in
 the same phase, it is usually appropriate for a terminating process
 to <i>resign</i> first.  Otherwise, its sibling processes will never be
 able to complete another synchronisation.
 </p>
 <p>
 <i>Warning:</i> the rules in the first two sentences above are
 the responsibility of the designer -- they are not checked by
 implementation.
 If not honoured, things will go wrong.
 </p>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/jcsp/lang/BarrierError.html" title="class in org.jcsp.lang">BarrierError</A></CODE> - if not enrolled <i>(but this is not always detected)</i>.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>CSP for Java<br>(JCSP) 1.1-rc4</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jcsp/lang/Any2OneConnection.html" title="interface in org.jcsp.lang"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jcsp/lang/BarrierError.html" title="class in org.jcsp.lang"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jcsp/lang/Barrier.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Barrier.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=\'-1\'><A HREF=\'mailto:jcsp-team@kent.ac.uk\'>Submit a bug or feature to jcsp-team@kent.ac.uk</A><br>Version 1.1-rc4 of the JCSP API Specification (Copyright 1997-2008 P.D.Austin and P.H.Welch - All Rights Reserved)<br>Java is a trademark or registered trademark of Sun Microsystems, Inc. in the US and other countries.
</BODY>
</HTML>
